# -*- coding: utf-8 -*-
"""car-detection-using-yolov5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dHR5GMn-wEox3YEkjTRnqUUI6C-9yOC1
"""

!git clone https://github.com/ultralytics/yolov5.git
!pip install -r yolov5/requirements.txt

import pandas as pd
import cv2
import os
import shutil
import yaml
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import random
import numpy as np
import torch
from pathlib import Path
from yolov5.models.yolo import Model
from PIL import Image
import sys
from IPython.display import display

input_data_path = '/kaggle/input/car-object-detection'
output_path = os.getcwd()

df = pd.read_csv(os.path.join(input_data_path, 'data/train_solution_bounding_boxes (1).csv'))

def get_width_and_height(img_path):
    img = cv2.imread(img_path)
    height, width, _ = img.shape
    return height, width

def convert_to_yolo_bbox(bbox, w, h):
    x_center = ((bbox[2] + bbox[0]) / 2) / w
    y_center = ((bbox[3] + bbox[1]) / 2) / h
    width = (bbox[2] - bbox[0]) / w
    height = (bbox[3] - bbox[1]) / h
    return x_center, y_center, width, height

def prepare_data(df):
    data = {'image': [], 'bbox_x': [], 'bbox_y': [], 'bbox_width': [], 'bbox_height': [], 'class': []}
    images_width = {}
    images_height = {}
    for _, row in df.iterrows():
        img_path = os.path.join(input_data_path, 'data/training_images', row['image'])
        height, width = get_width_and_height(img_path)
        x_center, y_center, width_bbox, height_bbox = convert_to_yolo_bbox(row[1:], width, height)
        data['image'].append(row['image'])
        data['bbox_x'].append(x_center)
        data['bbox_y'].append(y_center)
        data['bbox_width'].append(width_bbox)
        data['bbox_height'].append(height_bbox)
        data['class'].append(0)  # assuming 'car' is the only class
        images_width[row['image']] = width
        images_height[row['image']] = height
    df_yolo = pd.DataFrame(data)
    df_yolo['bboxes'] = df_yolo[['bbox_x', 'bbox_y', 'bbox_width', 'bbox_height']].apply(list, axis=1)
    df_yolo = df_yolo.drop(columns=['bbox_x', 'bbox_y', 'bbox_width', 'bbox_height'])
    df_yolo['height'] = df_yolo['image'].map(images_height)
    df_yolo['width'] = df_yolo['image'].map(images_width)
    df_yolo = df_yolo.groupby('image').agg(list).reset_index()
    return df_yolo

df_yolo = prepare_data(df)

train_df, val_df = train_test_split(df_yolo, test_size=0.2)
train_images_names = train_df['image'].to_list()
val_images_names = val_df['image'].to_list()

data_path = os.path.join(output_path, 'yolov5', 'car_detect')
train_path = os.path.join(data_path, 'train')
val_path = os.path.join(data_path, 'val')

train_images_path = os.path.join(train_path, 'images')
train_labels_path = os.path.join(train_path, 'labels')
val_images_path = os.path.join(val_path, 'images')
val_labels_path = os.path.join(val_path, 'labels')

test_img_path_start = os.path.join(input_data_path, 'data/testing_images')
test_img_path = os.path.join(output_path, 'test_images')
test_img_names = os.listdir(test_img_path_start)

def ensure_dir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)

ensure_dir(train_path)
ensure_dir(val_path)
ensure_dir(test_img_path)
ensure_dir(train_images_path)
ensure_dir(train_labels_path)
ensure_dir(val_images_path)
ensure_dir(val_labels_path)

def copy_images(img_names, src_dir, dest_dir):
    for img_name in img_names:
        src = os.path.join(src_dir, img_name)
        dest = os.path.join(dest_dir, img_name)
        if os.path.isfile(src):
            shutil.copy(src, dest)
        else:
            print(f"Warning: Image {src} not found.")

def make_labels_files(df, label_path):
    for _, row in df.iterrows():
        with open(f"{os.path.join(label_path, row['image'][:-3])}txt", 'w') as file:
            text = ''
            for bbox in row['bboxes']:
                text += f'{row["class"][0]} {bbox[0]} {bbox[1]} {bbox[2]} {bbox[3]}\n'
            file.write(text)

make_labels_files(train_df, train_labels_path)
make_labels_files(val_df, val_labels_path)

copy_images(train_images_names, os.path.join(input_data_path, 'data/training_images'), train_images_path)
copy_images(val_images_names, os.path.join(input_data_path, 'data/training_images'), val_images_path)
copy_images(test_img_names, test_img_path_start, test_img_path)

data_path = '/kaggle/working/yolov5/car_detect'
data_yaml_path = os.path.join(data_path, 'data.yaml')

data = {
    'train': os.path.join(data_path, 'train', 'images'),
    'val': os.path.join(data_path, 'val', 'images'),
    'test': os.path.join(data_path, 'test_images'),
    'nc': 1,
    'names': ['car']
}

with open(data_yaml_path, 'w') as f:
    yaml.dump(data, f)

print(f"Created data.yaml at {data_yaml_path}")

!ls /kaggle/working/yolov5/car_detect/train

!ls /kaggle/working/yolov5/car_detect

!export WANDB_MODE=disabled && cd yolov5 && python train.py --img-size 640 --batch-size 16 --epochs 50 --data {data_path}/data.yaml --cfg yolov5s.yaml --weights '' --name yolov5_car_detection --cache

!cd yolov5 && python detect.py --weights /kaggle/working/yolov5/runs/train/yolov5_car_detection/weights/best.pt --img-size 640 --conf-thres 0.4 --source /kaggle/working/test_images --save-txt --save-crop

def display_predictions(image_path, label_dir):
    img = cv2.imread(image_path)
    if img is None:
        print(f"Error: Unable to open image file {image_path}.")
        return
    img_height, img_width = img.shape[:2]
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    fig, ax = plt.subplots(1, figsize=(12, 9))
    ax.imshow(img_rgb)
    label_file = os.path.join(label_dir, os.path.splitext(os.path.basename(image_path))[0] + '.txt')
    if not os.path.isfile(label_file):
        print(f"Warning: No label file found for {image_path}.")
        plt.axis('off')
        plt.close(fig)
        return
    with open(label_file, 'r') as file:
        for line in file:
            parts = line.strip().split()
            if len(parts) < 5:
                print(f"Warning: Incorrect format in label file {label_file}.")
                continue
            class_id, x_center, y_center, width, height = map(float, parts)
            x_center *= img_width
            y_center *= img_height
            width *= img_width
            height *= img_height
            x_min = x_center - width / 2
            y_min = y_center - height / 2
            rect = patches.Rectangle(
                (x_min, y_min),
                width,
                height,
                linewidth=1,
                edgecolor='r',
                facecolor='none'
            )
            ax.add_patch(rect)
    ax.set_title(os.path.basename(image_path))
    ax.axis('off')  # Hide the axis
    plt.close(fig)  # Close the figure to avoid memory issues
    display(fig)  # Display the figure

test_img_path = '/kaggle/working/test_images'
label_path = '//kaggle/working/yolov5/runs/detect/exp/labels'
test_images = [f for f in os.listdir(test_img_path) if f.lower().endswith(('.jpg', '.png'))]
random_images = random.sample(test_images, min(15, len(test_images)))

for file_name in random_images:
    image_path = os.path.join(test_img_path, file_name)
    display_predictions(image_path, label_path)

!python yolov5/export.py --weights /kaggle/working/yolov5/runs/train/yolov5_car_detection/weights/best.pt --img-size 640 --batch-size 1 --device cpu --include onnx

sys.path.append('/kaggle/working/yolov5')
model_path = '/kaggle/working/yolov5/runs/train/yolov5_car_detection/weights/best.pt'
model = torch.hub.load('/kaggle/working/yolov5', 'custom', path=model_path, source='local')
model.eval()

test_images_dir = '/kaggle/input/car-detection-testing'

def predict_images(model, image_dir):
    image_paths = list(Path(image_dir).glob('*.*'))
    results = []
    for image_path in image_paths:
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"Skipping file (not an image or corrupted): {image_path}")
            continue
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        results.append((image_path, model(img_rgb)))
    return results

results = predict_images(model, test_images_dir)

for img_path, result in results:
    pred_df = result.pandas().xyxy[0]
    print(f"Processing: {img_path.name}")
    print(f"Predictions for {img_path.name}:")
    print(pred_df)
    print("\n")

def draw_boxes(img, pred, image_name, max_size=(1024, 768)):
    height, width = img.shape[:2]
    scale = min(max_size[0] / width, max_size[1] / height)
    new_width = int(width * scale)
    new_height = int(height * scale)
    resized_img = cv2.resize(img, (new_width, new_height))
    img_rgb = cv2.cvtColor(resized_img, cv2.COLOR_BGR2RGB)
    fig, ax = plt.subplots(1, figsize=(12, 9))
    ax.imshow(img_rgb)
    pred_df = pred.pandas().xyxy[0]
    if not pred_df.empty:
        for _, row in pred_df.iterrows():
            x_min = int(row["xmin"] * scale)
            y_min = int(row["ymin"] * scale)
            x_max = int(row["xmax"] * scale)
            y_max = int(row["ymax"] * scale)
            label = f'{row["name"]} {row["confidence"]:.2f}'
            rect = patches.Rectangle(
                (x_min, y_min),
                x_max - x_min,
                y_max - y_min,
                linewidth=2,
                edgecolor='r',
                facecolor='none'
            )
            ax.add_patch(rect)
            plt.text(x_min, y_min - 10, label, color='r', fontsize=10, weight='bold')
    ax.set_title(f'Predictions for {image_name}')
    ax.axis('off')
    plt.close(fig)
    display(fig)

for img_path, result in results:
    img = cv2.imread(str(img_path))
    if img is not None:
        image_name = img_path.name
        draw_boxes(img, result, image_name)